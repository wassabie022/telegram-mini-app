{"version":3,"file":"index.js","sources":["../src/errors/TypedError.ts","../src/addEventListener.ts","../src/createCbCollector.ts","../src/errors/isErrorOfType.ts","../src/errors/createTypedErrorPredicate.ts","../src/async/errors.ts","../src/async/promises/CancelablePromise.ts","../src/async/promises/EnhancedPromise.ts","../src/async/sleep.ts","../src/storage/storage.ts","../src/casing.ts","../src/createLogger.ts","../src/css-vars.ts"],"sourcesContent":["export interface TypedErrorOptions {\n  message?: string;\n  cause?: unknown;\n}\n\nexport class TypedError<T extends string> extends Error {\n  constructor(type: T, options?: TypedErrorOptions);\n  constructor(type: T, message?: string, cause?: unknown);\n  constructor(public readonly type: T, messageOrOptions?: string | TypedErrorOptions, cause?: unknown) {\n    super(\n      typeof messageOrOptions === 'object' ? messageOrOptions.message : messageOrOptions || type,\n      {\n        cause: typeof messageOrOptions === 'object' ? messageOrOptions.cause : cause,\n      },\n    );\n    Object.setPrototypeOf(this, TypedError.prototype);\n  }\n}\n","export function addEventListener<E, L extends (...args: any[]) => any>(\n  obj: {\n    addEventListener(type: E, listener: L): void;\n    removeEventListener(type: E, listener: L): void;\n  },\n  type: E,\n  listener: L\n) {\n  obj.addEventListener(type, listener);\n  return () => obj.removeEventListener(type, listener);\n}","export type CallbackFn = () => void;\n\n/**\n * Returns a tuple, containing function to add cleanup, call cleanup, and flag showing whether\n * cleanup was called. Cleanup will not be performed in case, it was done before.\n */\nexport function createCbCollector(...cbs: (CallbackFn | CallbackFn[])[]): [\n  add: (...fns: CallbackFn[]) => void,\n  call: () => void,\n] {\n  const callbacks = cbs.flat(1);\n\n  return [\n    callbacks.push.bind(callbacks),\n    () => {\n      callbacks.forEach(cb => {\n        cb();\n      });\n    },\n  ];\n}","import { TypedError } from '@/errors/TypedError.js';\n\n/**\n * @returns True, if the specified value is a TypedError of the specified type.\n * @param value - value to check.\n * @param type - error type.\n */\nexport function isErrorOfType<T extends string>(value: unknown, type: T): value is TypedError<T> {\n  return value instanceof TypedError && value.type === type;\n}","import { TypedError } from './TypedError.js';\nimport { isErrorOfType } from '@/errors/isErrorOfType.js';\n\nexport function createTypedErrorPredicate<T extends string>(\n  type: T,\n): (value: unknown) => value is TypedError<T> {\n  return (value): value is TypedError<T> => isErrorOfType(value, type);\n}","import { TypedError } from '@/errors/TypedError.js';\nimport { createTypedErrorPredicate } from '@/errors/createTypedErrorPredicate.js';\n\nexport const ERR_ABORTED = 'ERR_ABORTED';\nexport const ERR_CANCELED = 'ERR_CANCELED';\nexport const ERR_TIMED_OUT = 'ERR_TIMED_OUT';\n\nexport function createAbortError(cause?: unknown): TypedError<typeof ERR_ABORTED> {\n  return new TypedError(ERR_ABORTED, { cause });\n}\n\nexport const isTimeoutError = createTypedErrorPredicate(ERR_TIMED_OUT);\n\nexport const isAbortError = createTypedErrorPredicate(ERR_ABORTED);\n\nexport const isCanceledError = createTypedErrorPredicate(ERR_CANCELED);","import { TypedError } from '@/errors/TypedError.js';\nimport { addEventListener } from '@/addEventListener.js';\nimport { createCbCollector } from '@/createCbCollector.js';\nimport { createAbortError, ERR_CANCELED, ERR_TIMED_OUT } from '@/async/errors.js';\nimport type { Maybe } from '@/types/misc.js';\nimport type { AsyncOptions } from '@/async/types.js';\n\nimport type {\n  PromiseExecutorFn,\n  PromiseOnRejectedFn,\n  PromiseRejectFn,\n  PromiseOnFulfilledFn,\n  PromiseResolveFn,\n} from './types.js';\n\nfunction assignReject<P extends CancelablePromise<any>>(\n  childPromise: P,\n  parentPromise: CancelablePromise<any>,\n): P {\n  childPromise.reject = parentPromise.reject;\n  return childPromise;\n}\n\n/**\n * Improved version of the JavaScript Promise.\n */\nexport class CancelablePromise<Result> extends Promise<Result> {\n  /**\n   * Creates a new BetterPromise instance using executor, resolving promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static withFn<T>(\n    fn: (abortSignal: AbortSignal) => (T | PromiseLike<T>),\n    options?: AsyncOptions,\n  ): CancelablePromise<T> {\n    return new CancelablePromise((res, rej, signal) => {\n      try {\n        const result = fn(signal);\n        return result instanceof Promise ? result.then(res, rej) : res(result);\n      } catch (e) {\n        rej(e);\n      }\n    }, options);\n  }\n\n  /**\n   * @see Promise.resolve\n   */\n  static override resolve(): CancelablePromise<void>;\n  /**\n   * @see Promise.resolve\n   */\n  static override resolve<T>(value: T | PromiseLike<T>): CancelablePromise<Awaited<T>>;\n  /**\n   * @see Promise.resolve\n   */\n  static override resolve<T>(value?: T | PromiseLike<T>): CancelablePromise<Awaited<T>> {\n    return new CancelablePromise(resolve => {\n      resolve(value as Awaited<T>);\n    });\n  }\n\n  /**\n   * @see Promise.reject\n   */\n  static override reject<T = never>(reason?: any): CancelablePromise<T> {\n    return new CancelablePromise((_, reject) => {\n      reject(reason);\n    });\n  }\n\n  /**\n   * Creates a new BetterPromise instance using only options.\n   * @param options - additional options.\n   */\n  constructor(options?: AsyncOptions);\n  /**\n   * Creates a new BetterPromise instance using specified executor and additional options.\n   * @param executor - promise executor.\n   * @param options - additional options.\n   */\n  constructor(executor?: PromiseExecutorFn<Result>, options?: AsyncOptions);\n  constructor(\n    executorOrOptions?: PromiseExecutorFn<Result> | AsyncOptions,\n    maybeOptions?: AsyncOptions,\n  ) {\n    let executor: PromiseExecutorFn<Result> | undefined;\n    let options: AsyncOptions | undefined;\n\n    if (typeof executorOrOptions === 'function') {\n      executor = executorOrOptions;\n      options = maybeOptions;\n    } else {\n      options = executorOrOptions;\n    }\n\n    let resolve!: PromiseResolveFn<Result>;\n    let reject!: PromiseRejectFn;\n    super((res, rej) => {\n      // If an abort signal was passed initially in the promise, and it was in aborted state, it\n      // means that we have to prevent the executor from being called, just because there is no\n      // reason to do it.\n      //\n      // This signal will not be passed in case the promise was constructed via the \"then\" or\n      // \"finally\" methods, so we wouldn't have any related problems due to unhandled promise\n      // rejections.\n      options ||= {};\n      const { abortSignal } = options;\n      if (abortSignal && abortSignal.aborted) {\n        return rej(createAbortError(abortSignal.reason));\n      }\n\n      /* CLEANUP */\n      const [addCleanup, cleanup] = createCbCollector();\n      const withCleanup = <F extends (...args: any) => any>(fn: F): F => {\n        return ((...args) => {\n          cleanup();\n          return fn(...args);\n        }) as F;\n      };\n\n      // We are going to use our controller signal in the executor because we can control it.\n      // We can't say the same about the abort signal passed from above, we can't abort it by\n      // ourselves.\n      const controller = new AbortController();\n      const { signal: controllerSignal } = controller;\n\n      // The reject method should just abort the controller signal. In turn, it will reject\n      // the promise and notify the executor about the rejection.\n      reject = withCleanup(reason => {\n        controller.abort(reason);\n        rej(reason);\n      });\n      resolve = withCleanup(res) as PromiseResolveFn<Result>;\n\n      /* ABORT SIGNAL */\n      abortSignal && addCleanup(\n        addEventListener(abortSignal, 'abort', () => {\n          reject(createAbortError(abortSignal.reason));\n        }),\n      );\n\n      /* TIMEOUT */\n      const { timeout } = options;\n      if (timeout) {\n        const timeoutId = setTimeout(() => {\n          reject(new TypedError(ERR_TIMED_OUT, `Timeout reached: ${timeout}ms`));\n        }, timeout);\n\n        addCleanup(() => {\n          clearTimeout(timeoutId);\n        });\n      }\n\n      executor && executor(resolve, reject, controllerSignal);\n    });\n\n    this.reject = reject;\n  }\n\n  /**\n   * Cancels the promise execution.\n   */\n  cancel(): void {\n    this.reject(new TypedError(ERR_CANCELED));\n  }\n\n  /**\n   * @see Promise.catch\n   */\n  override catch<CatchResult = never>(\n    onRejected?: Maybe<PromiseOnRejectedFn<CatchResult>>,\n  ): CancelablePromise<Result | CatchResult> {\n    return this.then(undefined, onRejected);\n  }\n\n  /**\n   * @see Promise.finally\n   */\n  override finally(onFinally?: Maybe<() => void>): CancelablePromise<Result> {\n    return assignReject(super.finally(onFinally) as CancelablePromise<Result>, this);\n  }\n\n  /**\n   * Rejects the promise.\n   */\n  reject!: PromiseRejectFn;\n\n  /**\n   * @see Promise.then\n   */\n  override then<A = Result, B = never>(\n    onFulfilled?: Maybe<PromiseOnFulfilledFn<Result, A>>,\n    onRejected?: Maybe<PromiseOnRejectedFn<B>>,\n  ): CancelablePromise<A | B> {\n    return assignReject(super.then(onFulfilled, onRejected) as CancelablePromise<A | B>, this);\n  }\n}\n","import type { AsyncOptions } from '@/async/types.js';\n\nimport { CancelablePromise } from './CancelablePromise.js';\nimport type {\n  PromiseExecutorFn,\n  PromiseOnRejectedFn,\n  PromiseOnFulfilledFn,\n  PromiseResolveFn,\n} from './types.js';\nimport type { Maybe } from '@/types/misc.js';\n\nfunction assignResolve<P extends EnhancedPromise<any>>(\n  childPromise: P,\n  parentPromise: EnhancedPromise<any>,\n): P {\n  childPromise.resolve = parentPromise.resolve;\n  return childPromise;\n}\n\nexport class EnhancedPromise<Result, Resolvable = Result> extends CancelablePromise<Result> {\n  /**\n   * Creates a new EnhancedPromise instance using executor, resolving promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static withFn<T>(\n    fn: (abortSignal: AbortSignal) => (T | PromiseLike<T>),\n    options?: AsyncOptions,\n  ): EnhancedPromise<T> {\n    return new EnhancedPromise<T>(\n      (res, rej, abortSignal) => {\n        return CancelablePromise.withFn(fn, { abortSignal }).then(res, rej);\n      },\n      options,\n    );\n  }\n\n  /**\n   * @see Promise.resolve\n   */\n  static override resolve<Resolvable>(): EnhancedPromise<void, Resolvable>;\n  /**\n   * @see Promise.resolve\n   */\n  static override resolve<Result, Resolvable = Result>(\n    value: Result,\n  ): EnhancedPromise<Result, Resolvable>;\n  /**\n   * @see Promise.resolve\n   */\n  static override resolve<Result, Resolvable = Result>(\n    value?: Result,\n  ): EnhancedPromise<Result, Resolvable> {\n    return new EnhancedPromise(resolve => {\n      resolve(value as Result);\n    });\n  }\n\n  /**\n   * @see Promise.reject\n   */\n  static override reject<Result = never, Resolvable = Result>(\n    reason?: any,\n  ): EnhancedPromise<Result, Resolvable> {\n    return new EnhancedPromise((_, reject) => {\n      reject(reason);\n    });\n  }\n\n  /**\n   * Creates a new BetterPromise instance using only options.\n   * @param options - additional options.\n   */\n  constructor(options?: AsyncOptions);\n  /**\n   * Creates a new BetterPromise instance using specified executor and additional options.\n   * @param executor - promise executor.\n   * @param options - additional options.\n   */\n  constructor(executor?: PromiseExecutorFn<Result>, options?: AsyncOptions);\n  constructor(\n    executorOrOptions?: PromiseExecutorFn<Result> | AsyncOptions,\n    maybeOptions?: AsyncOptions,\n  ) {\n    let executor: PromiseExecutorFn<Result> | undefined;\n    let options: AsyncOptions | undefined;\n\n    if (typeof executorOrOptions === 'function') {\n      executor = executorOrOptions;\n      options = maybeOptions;\n    } else {\n      options = executorOrOptions;\n    }\n\n    let resolve!: PromiseResolveFn<Result>;\n    super((res, rej, signal) => {\n      resolve = res;\n      executor && executor(res, rej, signal);\n    }, options);\n\n    this.resolve = resolve as unknown as PromiseResolveFn<Resolvable>;\n  }\n\n  /**\n   * @see Promise.catch\n   */\n  override catch<CatchResult = never>(\n    onRejected?: Maybe<PromiseOnRejectedFn<CatchResult>>,\n  ): EnhancedPromise<Result | CatchResult, Resolvable> {\n    return this.then(undefined, onRejected);\n  }\n\n  /**\n   * @see Promise.finally\n   */\n  override finally(onFinally?: Maybe<() => void>): EnhancedPromise<Result, Resolvable> {\n    return assignResolve(super.finally(onFinally) as EnhancedPromise<Result, Resolvable>, this);\n  }\n\n  /**\n   * Resolves the promise.\n   */\n  resolve!: PromiseResolveFn<Resolvable>;\n\n  /**\n   * @see Promise.then\n   */\n  override then<A = Result, B = never>(\n    onFulfilled?: Maybe<PromiseOnFulfilledFn<Result, A>>,\n    onRejected?: Maybe<PromiseOnRejectedFn<B>>,\n  ): EnhancedPromise<A | B, Resolvable> {\n    return assignResolve(super.then(onFulfilled, onRejected) as EnhancedPromise<A | B, Resolvable>, this);\n  }\n}","import { CancelablePromise } from '@/async/promises/CancelablePromise.js';\n\n/**\n * Awaits for specified amount of time.\n * @param duration - duration in ms to await.\n * @param abortSignal - signal to stop function execution.\n */\nexport function sleep(duration: number, abortSignal?: AbortSignal): CancelablePromise<void> {\n  return new CancelablePromise(r => {\n    setTimeout(r, duration);\n  }, { abortSignal });\n}\n","/**\n * Converts a passed storage key to the formatted state.\n * @param key - storage key.\n */\nfunction formatKey(key: string): string {\n  return `tapps/${key}`;\n}\n\n/**\n * Saves value in the storage.\n * @param key - storage key.\n * @param value - storage value.\n */\nexport function setStorageValue<T>(key: string, value: T): void {\n  sessionStorage.setItem(formatKey(key), JSON.stringify(value));\n}\n\n/**\n * Extracts value from the storage.\n * @param key - storage key.\n */\nexport function getStorageValue<R>(key: string): R | undefined {\n  const value = sessionStorage.getItem(formatKey(key));\n  try {\n    return value ? JSON.parse(value) as R : undefined;\n  } catch {\n  }\n}\n","/**\n * Converts value from camel case to kebab case.\n * @param value - value to convert.\n */\nexport function camelToKebab(value: string): string {\n  return value.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n}\n\n/**\n * Converts value from camel case to snake case.\n * @param value - value to convert.\n */\nexport function camelToSnake(value: string): string {\n  return value.replace(/[A-Z]/g, (match) => `_${match.toLowerCase()}`);\n}\n\n/**\n * Converts value from snake case to camel case.\n * @param value - value to convert.\n */\nexport function snakeToCamel(value: string): string {\n  return value.replace(/_[a-z]/g, (m) => m[1].toUpperCase());\n}\n","/**\n * Message log level.\n */\nexport type LogLevel = 'log' | 'error';\n\nexport interface LoggerOptions {\n  bgColor?: string;\n  textColor?: string;\n  /**\n   * Should return true if log should be outputted.\n   * @default All logs will be outputted.\n   */\n  shouldLog?: boolean | (() => boolean);\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nexport function createLogger(scope: string, options?: LoggerOptions): [\n  /**\n   * Prints log message into a console.\n   * @param args\n   */\n  log: (...args: any[]) => void,\n  /**\n   * Prints error message into a console.\n   * @param args\n   */\n  error: (...args: any[]) => void,\n] {\n  options ||= {};\n  const {\n    textColor,\n    bgColor,\n    shouldLog = true,\n  } = options;\n\n  /**\n   * Prints message into a console in case, logger is currently enabled.\n   * @param level - log level.\n   * @param args - arguments.\n   */\n  function print(level: LogLevel, ...args: any[]): void {\n    if (!shouldLog || (typeof shouldLog === 'function' && !shouldLog())) {\n      return;\n    }\n    const commonCss = 'font-weight:bold;padding:0 5px;border-radius:5px';\n    console[level](\n      `%c${\n        Intl\n          .DateTimeFormat('en-GB', {\n            hour: '2-digit',\n            minute: '2-digit',\n            second: '2-digit',\n            fractionalSecondDigits: 3,\n            timeZone: 'UTC',\n          })\n          .format(new Date())\n      }%c / %c${scope}`,\n      `${commonCss};background-color: lightblue;color:black`,\n      '',\n      `${commonCss};${textColor ? `color:${textColor};` : ''}${bgColor ? `background-color:${bgColor}` : ''}`,\n      ...args,\n    );\n  }\n\n  return [\n    function log(...args: any[]): void {\n      print('log', ...args);\n    },\n    function error(...args: any[]): void {\n      print('error', ...args);\n    },\n  ];\n}","/**\n * Sets CSS variable globally.\n * @param name - variable name.\n * @param value - variable value.\n */\nexport function setCssVar(name: string, value: string | null): void {\n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Deletes specified CSS variable.\n * @param name - variable name.\n */\nexport function deleteCssVar(name: string): void {\n  document.documentElement.style.removeProperty(name);\n}\n"],"names":["TypedError","type","messageOrOptions","cause","addEventListener","obj","listener","createCbCollector","cbs","callbacks","cb","isErrorOfType","value","createTypedErrorPredicate","ERR_ABORTED","ERR_CANCELED","ERR_TIMED_OUT","createAbortError","isTimeoutError","isAbortError","isCanceledError","assignReject","childPromise","parentPromise","CancelablePromise","executorOrOptions","maybeOptions","executor","options","resolve","reject","res","rej","abortSignal","addCleanup","cleanup","withCleanup","fn","args","controller","controllerSignal","reason","timeout","timeoutId","__publicField","signal","result","e","_","onRejected","onFinally","onFulfilled","assignResolve","EnhancedPromise","sleep","duration","r","formatKey","key","setStorageValue","getStorageValue","camelToKebab","match","camelToSnake","snakeToCamel","m","createLogger","scope","textColor","bgColor","shouldLog","print","level","commonCss","setCssVar","name","deleteCssVar"],"mappings":"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"}