{"version":3,"file":"index.js","sources":["../src/batch.ts","../src/signal.ts","../src/computed.ts"],"sourcesContent":["import { Signal } from './signal.js';\n\nlet callbacks: Map<Signal<any>, () => void> | undefined;\n\nexport function runInBatchMode(signal: Signal<any>, fn: () => void): void {\n  callbacks && callbacks.set(signal, fn) || fn();\n}\n\n/**\n * Runs the specified function in the batch mode.\n *\n * It makes all signals' subscribers to be called only after signals changes inside the specified\n * function were applied.\n * @param fn - function to run in the batch mode.\n * @example\n * const a = signal(1);\n * const b = signal(1);\n * const c = computed(() => a() + b());\n *\n * function subscriber(value) {\n *   console.log(value);\n * }\n *\n * c.sub(subscriber);\n *\n * batch(() => {\n *   a.set(2);\n *   a.set(3);\n *   b.set(2);\n *   b.set(3);\n * });\n *\n * // Despite the fact that we called signals setters four times, the `subscriber` function will\n * // be called only once. Removing the `batch` function usage will lead to calling the `subscriber`\n * // function four times.\n */\nexport function batch(fn: () => void): void {\n  // There could be a case when a batch is called inside other batches.\n  // In this case, we should just ignore the current call.\n  if (callbacks) {\n    return fn();\n  }\n  callbacks = new Map();\n\n  try {\n    fn();\n  } finally {\n    callbacks.forEach(cb => cb());\n    callbacks = undefined;\n    // TODO: What if something went wrong in fn or its callbacks?\n  }\n}\n","import { collectSignal } from './computed.js';\nimport { runInBatchMode } from './batch.js';\n\nexport type SubscribeListenerFn<T> = (current: T, previous: T) => void;\nexport type RemoveListenerFn = () => void;\n\nexport interface SignalOptions<T> {\n  /**\n   * Previous and next values comparator.\n   *\n   * This function is used during the actual and incoming values comparison in the `set` method.\n   * If values are considered the same, no subscribers will be called.\n   *\n   * @default Object.is\n   * @param current - the actual value.\n   * @param next - an incoming value.\n   * @returns True if values are considered the same.\n   */\n  equals?: (current: T, next: T) => boolean;\n}\n\nexport interface SubOptions {\n  /**\n   * Should the listener be called only once.\n   */\n  once?: boolean;\n  /**\n   * Was this listener added by other signal.\n   */\n  signal?: boolean;\n}\n\nexport interface Signal<T> {\n  /**\n   * @returns An underlying signal value.\n   */\n  (): T;\n  /**\n   * Destroys the signal removing all bound listeners.\n   *\n   * We usually use this method when the signal is not needed anymore.\n   *\n   * Take note that as long as call of this method removes all bound listeners, computed signals\n   * based on the current one will stop listening to its changes, possibly making it work\n   * improperly.\n   */\n  destroy: () => void;\n  /**\n   * Resets the signal to its initial value.\n   */\n  reset: () => void;\n  /**\n   * Updates the signal notifying all subscribers about changes.\n   * @param value - value to set.\n   */\n  set: (value: T) => void;\n  /**\n   * Adds a new listener, tracking the signal changes.\n   * @param fn - event listener.\n   * @param onceOrOptions - was this listener added for a single call, or additional\n   * options.\n   * @returns A function to remove the bound listener.\n   */\n  sub: (fn: SubscribeListenerFn<T>, onceOrOptions?: boolean | SubOptions) => RemoveListenerFn;\n  /**\n   * Removes a listener, tracking the signal changes.\n   * @param fn - event listener.\n   * @param onceOrOptions - was this listener added for a single call, or additional\n   * options. Default: false\n   */\n  unsub: (fn: SubscribeListenerFn<T>, onceOrOptions?: boolean | SubOptions) => void;\n  /**\n   * Remove all non-signal listeners.\n   */\n  unsubAll: () => void;\n}\n\n/**\n * Creates a new signal with initial value.\n * @param initialValue - initial value.\n * @param options - additional options.\n */\nexport function signal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without initial value.\n * @param initialValue\n * @param options - additional options.\n */\nexport function signal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function signal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  type CurrentSignal = Signal<T | undefined>;\n\n  options ||= {};\n  const equals = options.equals || Object.is;\n\n  let listeners: [\n    listener: SubscribeListenerFn<T | undefined>,\n    options: Required<SubOptions>\n  ][] = [];\n  let value: ReturnType<CurrentSignal> = initialValue;\n\n  const set: CurrentSignal['set'] = v => {\n    if (!equals(value, v)) {\n      const prev = value;\n      value = v;\n\n      // We are making a copy of listeners as long as they may mutate the listeners' array,\n      // leading to an unexpected behavior.\n      //\n      // We want the setter to make sure that all listeners will be called in predefined\n      // order within a single update frame.\n      runInBatchMode(s, () => {\n        [...listeners].forEach(([fn, once]) => {\n          fn(v, prev);\n\n          // Remove \"once\" listeners.\n          if (once) {\n            unsub(fn, true);\n          }\n        });\n      });\n    }\n  };\n\n  function formatSubOptions(onceOrOptions: boolean | SubOptions | undefined): Required<SubOptions> {\n    const options = typeof onceOrOptions !== 'object'\n      ? { once: onceOrOptions }\n      : onceOrOptions;\n    return {\n      once: options.once || false,\n      signal: options.signal || false,\n    };\n  }\n\n  const unsub: CurrentSignal['unsub'] = (fn, onceOrOptions) => {\n    const options = formatSubOptions(onceOrOptions);\n    const idx = listeners.findIndex(([listener, lOptions]) => {\n      return listener === fn\n        && lOptions.once === options.once\n        && lOptions.signal === options.signal;\n    });\n    if (idx >= 0) {\n      listeners.splice(idx, 1);\n    }\n  };\n\n  const s = Object.assign(\n    function get() {\n      collectSignal(s);\n      return value;\n    },\n    {\n      destroy() {\n        listeners = [];\n      },\n      set,\n      reset() {\n        set(initialValue);\n      },\n      sub(fn, onceOrOptions) {\n        listeners.push([fn, formatSubOptions(onceOrOptions)]);\n        return () => unsub(fn, onceOrOptions);\n      },\n      unsub,\n      unsubAll() {\n        listeners = listeners.filter(l => l[1].signal);\n      },\n    } satisfies Pick<CurrentSignal, 'destroy' | 'set' | 'reset' | 'sub' | 'unsub' | 'unsubAll'>,\n  );\n\n  return s;\n}\n","import { signal, type Signal, type SignalOptions } from './signal.js';\n\nexport interface Computed<T> extends Omit<Signal<T>, 'set' | 'reset'> {\n  /**\n   * @returns An underlying signal value.\n   */\n  (): T;\n}\n\nconst collectContexts: Set<Signal<unknown>>[] = [];\n\nexport function collectSignal(signal: Signal<any>): void {\n  collectContexts.length && collectContexts[collectContexts.length - 1].add(signal);\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function computed<T>(\n  fn: (prev?: T) => T,\n  options?: SignalOptions<T>,\n): Computed<T> {\n  let deps = new Set<Signal<unknown>>();\n\n  // We set the initial value as undefined, because the computed signal is lazy.\n  // It will not be computed until it was either called or subscribed to.\n  const s = signal<T>(compute(), options);\n\n  function update() {\n    s.set(compute());\n  }\n\n  function compute(): T {\n    // As long as in this iteration, we may receive new signals as dependencies, we stop\n    // listening to the previous signals.\n    deps.forEach(s => s.unsub(update, { signal: true }));\n\n    // Signals we collected during current computation.\n    const collectedSignals = new Set<Signal<unknown>>();\n    let result: T;\n\n    // Add this set to the global variable, so dependant signals will be catched.\n    collectContexts.push(collectedSignals);\n\n    try {\n      // Run the function and collect all called signals.\n      result = fn();\n    } finally {\n      // Remember to untrack the reactive context.\n      collectContexts.pop();\n    }\n\n    // Start tracking for all dependencies' changes and re-compute the computed value.\n    collectedSignals.forEach(s => {\n      s.sub(update, { signal: true });\n    });\n    deps = collectedSignals;\n\n    return result;\n  }\n\n  return Object.assign(function computed(): T {\n    return s();\n  }, {\n    destroy: s.destroy,\n    sub: s.sub,\n    unsub: s.unsub,\n    unsubAll: s.unsubAll,\n  } satisfies Pick<Computed<T>, 'destroy' | 'sub' | 'unsub' | 'unsubAll'>);\n}\n"],"names":["callbacks","runInBatchMode","signal","fn","batch","cb","initialValue","options","equals","listeners","value","set","v","prev","s","once","unsub","formatSubOptions","onceOrOptions","idx","listener","lOptions","collectSignal","l","collectContexts","computed","deps","compute","update","collectedSignals","result"],"mappings":"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"}